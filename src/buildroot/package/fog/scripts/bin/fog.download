#!/bin/bash
. /usr/share/fog/lib/funcs.sh
. /bin/fog.donate
. /bin/fog.checkin
. /bin/fog.mount
. /bin/fog.checkmount
. /bin/fog.checkimgvar
imagePath="/images/$img"
origmac=$mac
mac=$(getMACAddresses | base64)
. /bin/fog.inventory "true"
mac="$origmac"
origmac=""
layPartSize="-1s"
fog.statusreporter $mac $web & disown
statusReporter="$!"
fixed_size_partitions=""
win7imgroot="$imagePath"
echo " * Using Image: $img"
case $imgType in
    [Nn]|mps|dd)
        dots "Looking for Hard Disk"
        getHardDisk
        if [[ -z $hd ]]; then
            echo "Failed"
            debugPause
            handleError "Could not find hard disk ($0)"
        fi
        echo "Done"
        debugPause
        diskSize=$(trim $(echo $(lsblk --bytes -dplno SIZE -I 3,8,9,179,259 $hd)))
        [[ $diskSize -gt 2199023255552 ]] && layPartSize="2tB"
        display_center "Using Disk: $hd"
        echo
        validResizeOS
        enableWriteCache $hd
        ;;
    mpa)
        dots "Looking for Hard Disks"
        getHardDisk "true"
        if [[ -z $disks ]]; then
            echo "Failed"
            debugPause
            handleError "Count not find any disks ($0)"
        fi
        echo "Done"
        debugPause
        display_center "Using Disks: $disks"
        ;;
esac
echo
echo " * Preparing Partition layout"
echo
case $imgType in
    [Nn])
        display_center "Wiping $hd partition information"
        echo
        initHardDisk $hd
        runPartprobe $hd
        do_fill="$(fillDiskWithPartitionsIsOK $hd $imagePath 1)"
        case $osid in
            50)
                [[ ! -d $imagePath ]] && handleError "Unable to locate image store ($0)"
                [[ $nombr -eq 1 ]] || prepareResizeDownloadPartitions
                ;;
            [1-2])
                [[ ! -f $imagePath && ! -f $imagePath/$img && ! -f $imagePath/d1p1.img ]] && handleError "Unable to locate image store ($0)"
                [[ -d $imagePath && -f $imagePath/$img ]] && imagePath="$imagePath/$img"
                [[ -d $imagePath && -f $imagePath/d1p1.img ]] && imagePath="$imagePath/d1p1.img"
                [[ $nombr -eq 1 ]] || restorePartitionTablesAndBootLoaders $hd 1 $imagePath
                dots "Removing partition"
                parted -s $hd rm 1 >/dev/null 2>&1
                if [[ ! $? -eq 0 ]]; then
                    echo "Failed"
                    debugPause
                    handleError "Fatal Error: Could not remove old partition ($0)"
                fi
                echo "Done"
                debugPause
                dots "Attempting to expand/fill partitions"
                case $do_fill in
                    0)
                        parted -s $hd mkpart primary ntfs 63s -- $layPartSize >/dev/null 2>&1
                        if [[ ! $? -eq 0 ]]; then
                            echo "Failed"
                            debugPause
                            handleError "Fatal Error: Could not recreate first partition ($0)"
                        fi
                        echo "Done"
                        debugPause
                        ;;
                    *)
                        fillDiskWithPartitions $hd $imagePath 1
                        echo "Done"
                        debugPause
                        ;;
                esac
                dots "Setting boot partition"
                parted -s $hd set 1 boot on >/dev/null 2>&1
                if [[ ! $? -eq 0 ]]; then
                    echo "Failed"
                    debugPause
                    handleError "Fatal Error: Could not make partition bootable ($0)"
                fi
                runPartprobe $hd
                echo "Done"
                debugPause
                getPartitions $hd
                for part in $parts; do
                    [[ -e $part ]] && break
                done
                ;;
            [5-7]|9)
                [[ ! -d $imagePath && ! -f $win7imgroot/sys.img.000 ]] && handleError "Unable to locate image store ($0)"
                [[ ! -f $win7imgroot/sys.img.000 && ! $nombr -eq 1 ]] && prepareResizeDownloadPartitions
                if [[ -f $win7imgroot/sys.img.000 && ! $nombr -eq 1 ]]; then
                    echo " * Using legacy style partition setup"
                    win7partcnt=1
                    dots "Windows Boot Partition Exists"
                    if [[ ! -f $win7imgroot/gpt.bak && ! -f $win7imgroot/rec1.img.000 && ! -f $win7imgroot/rec.img.000 ]]; then
                        echo "No"
                    else
                        echo "Yes"
                        [[ -f $win7imgroot/rec.img.000 ]] && win7partcnt=2
                        [[ -f $win7imgroot/rec.img.001 || -f $win7imgroot/gpt.bak ]] && win7partcnt=3
                    fi
                    debugPause
                    dots "Removing partition"
                    parted -s $hd rm 1 >/dev/null 2>&1
                    if [[ $? != 0 ]]; then
                        echo "Failed"
                        debugPause
                        handleError "Fatal Error: Could not remove old partition ($0)"
                    fi
                    echo "Done"
                    debugPause
                    case $win7partcnt in
                        1)
                            dots "Attempting to expand/fill partitions"
                            case $do_fill in
                                0)
                                    startsector="2048s"
                                    [[ $imgFormat -eq 1 || $imgLegacy -eq 1 ]] && startsector="63s"
                                    parted -s $hd mkpart primary ntfs $startsector -- $layPartSize >/dev/null 2>&1
                                    if [[ ! $? -eq 0 ]]; then
                                        echo "Failed"
                                        debugPause
                                        handleError "Fatal Error: Could not recreate first partition ($0)"
                                    fi
                                    echo "Done"
                                    debugPause
                                    ;;
                                *)
                                    fillDiskWithPartition $hd $imagePath 1
                                    echo "Done"
                                    debugPause
                                    ;;
                            esac
                            dots "Setting boot partition"
                            parted -s $hd set 1 boot on >/dev/null 2>&1
                            if [[ ! $? -eq 0 ]]; then
                                echo "Failed"
                                debugPause
                                handleError "Fatal Error: Could not make partition bootable ($0)"
                            fi
                            echo "Done"
                            debugPause
                            ;;
                        2)
                            dots "Attempting to expand/fill partitions"
                            case $do_fill in
                                0)
                                    startsector="2048s"
                                    [[ $imgFormat -eq 1 || $imgLegacy -eq 1 ]] && startsector="63s"
                                    parted -s $hd mkpart primary ntfs $startsector 206847s >/dev/null 2>&1
                                    startsector="$defaultpart2start"
                                    parted -s $hd mkpart primary ntfs $startsector -- $layPartSize >/dev/null 2>&1
                                    if [[ ! $? -eq 0 ]]; then
                                        echo "Failed"
                                        debugPause
                                        handleError "Fatal Error: Could not recreate main partition ($0)"
                                    fi
                                    echo "Done"
                                    debugPause
                                    dots "Setting boot partition"
                                    parted -s $hd set 1 boot on >/dev/null 2>&1
                                    if [[ ! $? -eq 0 ]]; then
                                        echo "Failed"
                                        debugPause
                                        handleError "Fatal Error: Could not make partition bootable ($0)"
                                    fi
                                    echo "Done"
                                    debugPause
                            dots "Setting boot partition"
                            parted -s $hd set 1 boot on >/dev/null 2>&1
                            if [[ ! $? -eq 0 ]]; then
                                echo "Failed"
                                debugPause
                                handleError "Fatal Error: Could not make partition bootable ($0)"
                            fi
                            echo "Done"
                            debugPause
                                    ;;
                                *)
                                    fillDiskWithPartitions $hd $imagePath 1
                                    echo "Done"
                                    debugPause
                                    ;;
                            esac
                            ;;
                        3)
                            dots "Ensuring $hd is clean"
                            sgdisk --zap-all $hd >/dev/null 2>&1
                            if [[ ! $? -eq 0 ]]; then
                                echo "Failed"
                                debugPause
                                handleError "Fatal Error: Could not clean disk ($0)"
                            fi
                            echo "Done"
                            debugPause
                            dots "Attempting to expand/fill partitions"
                            case $do_fill in
                                0)
                                    sgdisk --mbrtogpt --load-backup="$win7imgroot/gpt.bak" --move-second-header $hd >/dev/null 2>&1
                                    if [[ ! $? -eq 0 ]]; then
                                        echo "Failed"
                                        debugPause
                                        handleError "Fatal Error: Could not place partitions ($0)"
                                    fi
                                    sgdisk -x 3:$(sgdisk -E $hd) $hd >/dev/null 2>&1
                                    if [[ ! $? -eq 0 ]]; then
                                        echo "Failed"
                                        debugPause
                                        handleError "Fatal Error: Could not resize main partition ($0)"
                                    fi
                                    echo "Done"
                                    debugPause
                                    ;;
                                *)
                                    fillDiskWithPartitions $hd $imagePath 1
                                    echo "Done"
                                    debugPause
                                    ;;
                            esac
                            ;;
                    esac
                    runPartprobe $hd
                    dots "Setting up partition variables"
                    getPartitions $hd
                    for part in $parts; do
                        case $osid in
                            [1-2])
                                [[ -e $part ]] && break
                                ;;
                            [5-7]|9)
                                case $win7partcnt in
                                    1)
                                        [[ $(getPartitionNumber $part) -eq 1 ]] && win7sys="$part"
                                        ;;
                                    2)
                                        [[ $(getPartitionNumber $part) -eq 1 ]] && win7rec="$part"
                                        [[ $(getPartitionNumber $part) -eq 2 ]] && win7sys="$part"
                                        ;;
                                    3)
                                        [[ $(getPartitionNumber $part) -eq 1 ]] && win7rec1="$part"
                                        [[ $(getPartitionNumber $part) -eq 2 ]] && win7rec2="$part"
                                        [[ $(getPartitionNumber $part) -eq 3 ]] && win7sys="$part"
                                        ;;
                                esac
                                ;;
                        esac
                    done
                    echo "Done"
                    debugPause
                fi
                ;;
        esac
        ;;
    mps)
        [[ ! -d $imagePath ]] && handleError "Unable to locate image store ($0)"
        display_center "Wiping $hd partition information"
        initHardDisk $hd
        [[ $nombr -eq 1 ]] || restorePartitionTablesAndBootLoaders $hd 1 $imagePath
        runPartprobe $hd
        gptcheck="$global_gptcheck"
        ;;
    mpa)
        [[ ! -d $imagePath ]] && handleError "Unable to locate image store ($0)"
        getHardDisk "true"
        intDisk=1
        for disk in $disks; do
            display_center "Wiping $disk partition information"
            initHardDisk $disk
            [[ $nombr -eq 1 ]] || restorePartitionTablesAndBootLoaders $disk $intDisk $imagePath
            runPartprobe $disk
            gptcheck="$global_gptcheck"
            let intDisk+=1
        done
        ;;
esac
echo
display_center "+--------------------------------+"
display_center "|  Attempting to download image  |"
display_center "+--------------------------------+"
echo
display_center "+--------------------------------+"
[[ $imgFormat -eq 1 || $imgLegacy -eq 1 ]] && display_center "|         Using Partimage        |" || display_center "|         Using Partclone        |"
display_center "+--------------------------------+"
echo
[[ $mc == yes ]] && usleep 10000000 || usleep 3000000
case $imgType in
    [Nn])
        case $osid in
            [1-2])
                [[ ! -f $imagePath ]] && handleError "Fatal Error: Could not locate file ($0)"
                restorePartition $part
                ;;
            [5-7]|9)
                [[ ! -d $imagePath && ! -f $win7imgroot/sys.img.000 ]] && handleError "Fatal Error: Could not locate file ($0)"
                if [[ ! -f $win7imgroot/sys.img.000 ]]; then
                    # saveEBR/restoreEBR are to support the resized partitions,
                    # on MBR tables since the partition image will contain the
                    # old, and potentially incorrect, EBR Data
                    # If the partition does not make sense to save/restore the
                    # EBR, then the functions skip it.
                    recparts="$(getValidRestorePartitions $hd 1 $imagePath)"
                    for recpart in $recparts; do
                        tmpebrfilename="$(tmpEBRFileName 1 $(getPartitionNumber $recpart))"
                        saveEBR $recpart $tmpebrfilename
                        restorePartition $recpart
                        restoreEBR $recpart $tmpebrfilename
                        expandPartition $recpart
                    done
                    makeAllSwapSystems $hd 1 $imagePath $imgPartitionType
                else
                    case $win7partcnt in
                        1)
                            winparts="$(trim $(echo $win7sys))"
                            ;;
                        2)
                            winparts="$(trim $(echo "$win7rec $win7sys"))"
                            ;;
                        3)
                            winparts="$(trim $(echo "$win7rec1 $win7rec2 $win7sys"))"
                            ;;
                    esac
                    for winpart in $winparts; do
                        restorePartition $winpart
                    done
                    recparts="$(getValidRestorePartitions $hd 1 $imagePath)"
                    for recpart in $recparts; do
                        expandPartition $recpart
                    done
                    makeAllSwapSystems $hd 1 $imagePath $imgPartitionType
                fi
                ;;
            50)
                # saveEBR/restoreEBR are to support the resized partitions,
                # on MBR tables since the partition image will contain the
                # old, and potentially incorrect, EBR Data
                # If the partition does not make sense to save/restore the
                # EBR, then the functions skip it.
                recparts="$(getValidRestorePartitions $hd 1 $imagePath)"
                for recpart in $recparts; do
                    tmpebrfilename="$(tmpEBRFileName 1 $(getPartitionNumber $recpart))"
                    saveEBR $recpart $tmpebrfilename
                    restorePartition $recpart
                    restoreEBR $recpart $tmpebrfilename
                    expandPartition $recpart
                done
                makeAllSwapSystems $hd 1 $imagePath $imgPartitionType
                ;;
        esac
        ;;
    mps)
        recparts="$(getValidRestorePartitions $hd 1 $imagePath)"
        for recpart in $recparts; do
            [[ $imgPartitionType == all || $imgPartitionType == $(getPartitionNumber $recpart) ]] && restorePartition $recpart 1 $imagePath $imgPartitionType || echo " * Skipping partition $recpart"
        done
        makeAllSwapSystems $hd 1 $imagePath $imgPartitionType
        ;;
    mpa)
        for disk in $disks; do
            recparts="$(getValidRestorePartitions $disk 1 $imagePath)"
            for recpart in $recparts; do
                [[ $imgPartitionType == all || $imgPartitionType == $(getPartitionNumber $recpart) ]] && restorePartition $recpart $intDisk $imagePath $imgPartitionType || echo " * Skipping partition $recpart"
            done
            makeAllSwapSystems $disk 1 $imagePath $imgPartitionType
            let intDisk+=1
        done
        ;;
    dd)
        restorePartition $hd
        ;;
esac
killStatusReporter
if [[ -f /images/postdownloadscripts/fog.postdownload ]]; then
    postdownpath="/images/postdownloadscripts/"
    . ${postdownpath}fog.postdownload
fi
if [[ ! $capone -eq 1 ]]; then
    if [[ $osid == +([1-2]|[5-7]|9) ]]; then
        getHardDisk "true"
        for disk in $disks; do
            getPartitions $disk
            for part in $parts; do
                [[ $(fsTypeSetting $part) == ntfs ]] && changeHostname
            done
        done
    fi
    . /bin/fog.imgcomplete
fi
[[ ! $mode == debug && -z $isdebug ]] && echo " * Rebooting system as task is complete" || debugPause
