#!/bin/bash
. /usr/share/fog/lib/funcs.sh
. /bin/fog.donate
. /bin/fog.checkin
layPartSize="-1s"
imagePath="/images/$img"
fog.statusreporter "$mac" "$web" & disown
statusReporter="$!"
fixed_size_partitions=""
win7imgroot="$imagePath"
. /bin/fog.checkmount
. /bin/fog.checkimgvar
echo " * Using Image: $img"
case "$imgType" in
    [n]|mps|dd)
        dots "Looking for Hard Disk"
        getHardDisk
        if [[ -z $hd ]]; then
            echo "Failed"
            debugPause
            handleError "Count not find hard disk"
        fi
        echo "Done"
        debugPause
        diskSize=$(parted -s $hd u kB print | awk -F'[: ]+' /Disk\ \\//'{print $3+0}')
        if [[ $diskSize -gt 2199023256 ]]; then
            layPartSize="2tB"
        fi
        echo "Using Disk: $hd"
        validResizeOS
        enableWriteCache $hd
        ;;
    mpa)
        dots "Looking for Hard Disks"
        getHardDisk "true"
        if [[ -z $disks ]]; then
            echo "Failed"
            debugPause
            handleError "Count not find any disks"
        fi
        echo "Done"
        debugPause
        echo "Using Disks: $disks"
        ;;
esac
echo
echo " * Preparing Partition layout"
echo
case "$imgType" in
    n)
        echo "Wiping $hd partition information"
        initHardDisk $hd
        dots "Recreating partition layout"
        if [[ $nombr == 1 ]]; then
            echo "Skipped"
        else
            dd if=/dev/zero of=$hd bs=512 count=20 >/dev/null 2>&1
            if [[ $? != 0 ]]; then
                echo "Failed"
                debugPause
                handleError "Fatal Error: Could not clear partition table"
            fi
            parted -s $hd mktable msdos >/dev/null 2>&1
            if [[ $? != 0 ]]; then
                echo "Failed"
                debugPause
                handleError "Fatal Error: Could not initialize disk"
            fi
            dd if=$mbrfile of=$hd bs=512 count=1 >/dev/null 2>&1
            if [[ $? != 0 ]]; then
                echo "Failed"
                debugPause
                handleError "Fatal Error: Could not recreate MBR table"
            fi
        fi
        runPartprobe $hd
        echo "Done"
        debugPause
        dots "Removing partitions"
        case "$osid" in
            [1-2])
                if [[ ! -f $imagePath && ! -f $imagePath/$img ]]; then
                    handleError "Fatal Error: Could not locate image files"
                fi
                if [[ -d $imagePath ]]; then
                    imagePath="$imagePath/$img"
                fi
                dots "Preparing Hard Disks (Stage 2)"
                parted -s $hd rm 1 &>/dev/null
                echo "Done"
                debugPause
                dots "Preparing hard Disks (Stage 3)"
                parted -s $hd mkpart primary ntfs 63s -- $layPartSize &>/dev/null
                parted -s $hd set 1 boot on &>/dev/null
                runPartprobe $hd
                for part in $parts; do
                    break
                done
                echo "Done"
                debugPause
                ;;
            [5-7]|[9])
                if [[ -f $win7imgroot/sys.img.000 ]]; then
                    echo " * Using legacy style partition setup"
                    win7partcnt=1
                    dots "Windows Boot Partition Exists"
                    if [[ ! -f $win7imgroot/gpt.bak && ! -f $win7imgroot/rec1.img.000 && ! -f $win7imgroot/rec.img.000 ]]; then
                        echo "No"
                    else
                        echo "Yes"
                        if [[ -f $win7imgroot/rec.img.000 ]]; then
                            win7partcnt=2
                        elif [[ -f $win7imgroot/gpt.bak ]]; then
                            win7partcnt=3
                        fi
                    fi
                    debugPause
                    case "$win7partcnt" in
                        1)
                            dets "Removing partition"
                            parted -s $hd rm 1 >/dev/null 2>&1
                            if [[ $? != 0 ]]; then
                                echo "Failed"
                                debugPause
                                handleError "Fatal Error: Could not remove old partition"
                            fi
                            echo "Done"
                            debugPause
                            dots "Attempting to expand/fill partitions"
                            do_fill=$(fillDiskWithPartitionsIsOK "$hd" "$imagePath" "1")
                            if [[ $do_fill != 0 ]]; then
                                fillDiskWithPartitions "$hd" "$imagePath" "1"
                                echo "Done"
                            else
                                startsector="2048s"
                                if [[ $imgFormat == 1 || $imgLegacy == 1 ]]; then
                                    startsector="63s"
                                fi
                                parted -s $hd mkpart primary ntfs $startsector -- $layPartSize >/dev/null 2>&1
                                if [[ $? != 0 ]]; then
                                    echo "Failed"
                                    debugPause
                                    handleError "Fatal Error: Could not recreate first partition"
                                fi
                                echo "Done"
                            fi
                            debugPause
                            dots "Setting boot partition"
                            parted -s $hd set 1 boot on >/dev/null 2>&1
                            if [[ $? != 0 ]]; then
                                echo "Failed"
                                debugPause
                                handleError "Fatal Error: Could not make partition bootable"
                            fi
                            echo "Done"
                            debugPause
                            ;;
                        2)
                            dots "Removing main partition"
                            parted -s $hd rm 2 >/dev/null 2>&1
                            if [[ $? != 0 ]]; then
                                echo "Failed"
                                debugPause
                                handleError "Fatal Error: Could not remove old partition"
                            fi
                            echo "Done"
                            debugPause
                            dots "Attempting to expand/fill partitions"
                            do_fill=$(fillDiskWithPartitionsIsOK "$hd" "$imagePath" "1")
                            if [[ $do_fill != 0 ]]; then
                                fillDiskWithPartitions "$hd" "$imagePath" "1"
                                echo "Done"
                            else
                                startsector=$defaultpart2start
                                parted -s $hd mkpart primary ntfs $startsector -- $layPartSize >/dev/null 2>&1
                                if [[ $? != 0 ]]; then
                                    echo "Failed"
                                    debugPause
                                    handleError "Fatal Error: Could not recreate main partition"
                                fi
                                echo "Done"
                            fi
                            debugPause
                            ;;
                        3)
                            dots "Ensuring $hd is clean"
                            sgdisk --zap-all $hd >/dev/null 2>&1
                            if [[ $? != 0 ]]; then
                                echo "Failed"
                                debugPause
                                handleError "Fatal Error: Could not clean disk"
                            fi
                            echo "Done"
                            debugPause
                            dots "Setting partitions"
                            sgdisk --mbrtogpt --load-backup=$win7imgroot/gpt.bak --move-second-header $hd >/dev/null 2>&1
                            if [[ $? != 0 ]]; then
                                echo "Failed"
                                debugPause
                                handleError "Fatal Error: Could not place partitions"
                            fi
                            echo "Done"
                            debugPause
                            dots "Preparing Hard Disks (Stage 3)"
                            sgdisk -x 3:$(sgdisk -E $hd) $hd &>/dev/null
                            ;;
                    esac
                fi
        esac
        ;;
    mps)
        ;;
    mpa)
        ;;
    dd)
        ;;
esac
echo
echo " * Now FOG will attempt to download the image using Partclone"
echo


# Generates the partitions.  If singledisk resizeable, it generates
# based on default normal values.
# Otherwise it uses MBR/GPT to generate the partition table(s).
if [[ $imgType == n ]]; then
        debugPause
        if [[ $win7partcnt == 1 ]]; then
            dots "Preparing Hard Disks (Stage 2)"
            parted -s $hd rm 1 &>/dev/null
            echo "Done"
            debugPause
            dots "Preparing Hard Disks (Stage 3)"
            do_fill=$(fillDiskWithPartitionsIsOK "${hd}" "${imagePath}" "1")
            if [[ $do_fill != 0 ]]; then
                fillDiskWithPartitions "${hd}" "${imagePath}" "1"
        elif [[ $win7partcnt == 2 ]]; then
        elif [[ $win7partcnt == 3 ]]; then
        elif [[ $win7partcnt == 4 ]]; then
            dots "Preparing Hard Disks (Stage 2)"
            sgdisk --zap-all $hd >/dev/null 2>&1
            sgdisk --mbrtogpt --load-backup=$win7imgroot/gpt.bak --move-second-header $hd &>/dev/null
            echo "Done"
            debugPause
            dots "Preparing Hard Disks (Stage 3)"
            sgdisk -x 4:$(sgdisk -E $hd) $hd &>/dev/null
        fi
        runPartprobe $hd
        echo "Done"
        debugPause
        getPartitions $hd
        dots "Setting up partition variables"
        partCount=0
        for part in $parts; do
            partCount=$(($partCount + 1))
            if [[ $win7partcnt == 1 && $partCount == 1 ]]; then
                win7sys=$part
                break
            elif [[ $win7partcnt == 2 ]]; then
                if [[ $partCount == 1 ]]; then
                    win7rec=$part
                elif [[ $partCount == 2 ]]; then
                    win7sys=$part
                    break
                fi
                continue
            elif [[ $win7partcnt == 3 ]]; then
                if [[ $partCount == 1 ]]; then
                    win7rec1="$part"
                elif [[ $partCount == 2 ]]; then
                    win7rec2="$part"
                elif [[ $partCount == 3 ]]; then
                    win7sys="$part"
                    break
                fi
                continue
            fi
        done
        part=$win7sys
        partCount=0
        echo "Done"
    elif [[ -f $imagePath || -f $imagePath/$img ]] && [[ $osid == +([1-2]) ]]; then
        # Linux:
        #  restore MBR/GRUB
        #  resize original partition table to current disk, and apply it
    elif [[ $osid == +([1-2]|[5-7]|9|50) ]]; then
        restorePartitionTablesAndBootLoaders "$hd" "1" "$imagePath" "$osid" "$imgPartitionType"
        do_fill=$(fillDiskWithPartitionsIsOK "${hd}" "${imagePath}" "1")
        majorDebugEcho "Filling disk = $do_fill."
        dots "Expanding partition table to fill disk"
        if [[ $do_fill != 0 ]]; then
            fillDiskWithPartitions "${hd}" "${imagePath}" "1"
        fi
        echo "Done"
        debugPause
    fi
    usleep 3000000
elif [[ $imgType == mps ]]; then
    if [[ -d $imagePath ]]; then
        restorePartitionTablesAndBootLoaders "$hd" "1" "$imagePath" "$osid" "$imgPartitionType"
        gptcheck="$global_gptcheck"
    else
        handleError "Unable to locate image store."
    fi
elif [[ $imgType == mpa ]]; then
    getHardDisk "true"
    intDisk=1
    if [[ -d $imagePath ]]; then
        for disk in "$disks"; do
            restorePartitionTablesAndBootLoaders "$disk" "$intDisk" "$imagePath" "$osid" "$imgPartitionType"
            gptcheck="$global_gptcheck"
            intDisk=$(($intDisk + 1))
        done
    else
        handleError "Unable to locate image store."
    fi
fi
if [[ $imgType == n ]]; then
    getPartitions $hd
    if [[ -f $win7imgroot/sys.img.000 && $osid == +([5-7]|9) ]]; then
        if [[ $win7partcnt == 1 ]]; then
            restorePartition "$win7sys"
        elif [[ $win7partcnt == 2 ]]; then
            restorePartition "$win7rec"
            restorePartition "$win7sys"
        elif [ "$win7partcnt" == "3" ]; then
            restorePartition "$win7rec1"
            restorePartition "$win7rec2"
            restorePartition "$win7sys"
        fi
    elif [[ -f $imagePath ]] && [[ $osid == +(1|2) ]]; then
        restorePartition "$part"
    elif [[ $osid == +([1-2]|[5-7]|9|50) ]]; then
        for part in $parts; do
            # saveEBR/restoreEBR are to support the resized partitions, on MBR tables
            # since the partition image will contain the old (potentially incorrect) EBR data
            # If the partition doesn't make sense to save/restore EBR, then the functions skip it
            tmpebrfilename=$(tmpEBRFileName "1" "${partNum}")
            saveEBR "$part" "$tmpebrfilename"
            usleep 2000000
            restorePartition "$part"
            restoreEBR "$part" "$tmpebrfilename"
        done
        makeAllSwapSystems "$hd" "1" "$imagePath" "$imgPartitionType"
    fi
    killStatusReporter
    for part in $parts; do
        expandPartition "$part"
        fixWin7boot "$part"
    done
elif [ "$imgType" == "mps" ]; then
    for part in $(getValidRestorePartitions $hd 1 $imagePath); do
        partNum=$(getPartitionNumber $part)
        if [[ $imgPartitionType == all || $imgPartitionType == $partNum ]]; then
            restorePartition "$part" "1" "$imagePath" "$imgPartitionType"
        else
            echo " * Skipping partition $partNum"
        fi
    done
    makeAllSwapSystems "$hd" "1" "$imagePath" "$imgPartitionType"
    dots "Stopping FOG Status Reporter"
    kill -9 $statusReporter 2>/dev/null
    echo "Done"
elif [ "$imgType" == "mpa" ]; then
    intDisk=1
    for disk in $disks; do
        for part in $(getValidRestorePartitions $disk $intDisk $imagePath); do
            partNum=$(getPartitionNumber $part)
            if [[ $imgPartitionType == all || $imgPartitionType == $partNum ]]; then
                echo " * Processing Partition: $part ($partNum)"
                restorePartition "$part" "$intDisk" "$imagePath" "$imgPartitionType"
            else
                echo " * Skipping partition $partNum"
            fi
        done
        makeAllSwapSystems "$disk" "$intDisk" "$imagePath" "$imgPartitionType"
        intDisk=$(($intDisk + 1))
    done
    dots "Stopping FOG Status Reporter"
    kill -9 $statusReporter 2>/dev/null
    echo "Done"
else
    restorePartition "$hd"
    dots "Stopping FOG Status Reporter"
    kill -9 $statusReporter 2>/dev/null
    echo "Done"
fi
# This can mess with "mps" and UEFI bootloaders
# Should only be needed if the source and destination disks are on the same system
# if [ "$imgPartitionType" == "all" -o "$imgPartitionType" == "mbr" ]; then
# 	if [ "$gptcheck" == "yes" ]; then
# 		dots "Randomizing GUIDS";
# 		sgdisk -G $hd;
# 		echo "Done";
# 		debugPause;
# 	fi
# fi
if [[ -f /images/postdownloadscripts/fog.postdownload ]]; then
    postdownpath="/images/postdownloadscripts/"
    . ${postdownpath}fog.postdownload
fi
if [[ $capone != 1 ]]; then
    if [[ $osid == +([1-2]|[5-7]|9) ]]; then
        getHardDisk "true"
        intDisk=1
        for disk in "$disks"; do
            getPartitions $disk
            for part in $parts; do
                fstype=$(fsTypeSetting $part)
                if [ "$fstype" = "ntfs" ]; then
                    changeHostname;
                fi
            done
        done
    fi
    echo
    echo " * Updating Computer Database Status"
    echo
    cd /tmp
    queueinfo=""
    wget -q -O /tmp/co.txt "http://${web}service/Post_Stage3.php?mac=$mac&type=$type" &>/dev/null
    queueinfo=$(cat co.txt)
    while [[ $queueinfo != '##' ]]; do
        echo "		* $queueinfo"
        rm co.txt
        wget -q -O /tmp/co.txt "http://${web}service/Post_Stage3.php?mac=$mac&type=$type" &>/dev/null
        queueinfo=$(cat co.txt)
        usleep 5000000
    done
    echo
    echo " * Database Updated!"
    echo
    debugPause
fi
echo
echo " * Task is completed, computer will now restart."
echo
debugPause
