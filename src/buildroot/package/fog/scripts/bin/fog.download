#!/bin/bash
. /usr/share/fog/lib/funcs.sh
. /bin/fog.donate
. /bin/fog.checkin
dots "Mounting File System"
mkdir /images $debugstring 2>/dev/null
mount -o nolock,proto=tcp,rsize=32768,intr,noatime $storage /images 2>/tmp/mntfail
blame=""
count=0
if [[ ! $? -eq 0 && ! -f /images/.mntcheck ]]; then
    while [[ $blame != '##' ]]; do
        blame=$(wget --post-data="mac=$mac&type=$type" -qO - http://${web}service/blame.php 2>/dev/null)
        if [[ $count -ge 10 ]]; then
            echo "Failed"
            debugPause
            handleError "Error during failure notification: $blame"
        fi
        let count+=1
        usleep 5000000
    done
    echo "Failed"
    debugPause
    handleError "Error mounting NFS or .mntcheck file missing"
fi
echo "Done"
debugPause
origmac=$mac
mac=$(getMACAddresses | base64)
. /bin/fog.inventory "true"
mac=$origmac
origmac=""
layPartSize="-1s"
imagePath="/images/$img"
fog.statusreporter "$mac" "$web" & disown
statusReporter="$!"
fixed_size_partitions=""
win7imgroot="$imagePath"
. /bin/fog.checkmount
. /bin/fog.checkimgvar
echo " * Using Image: $img"
case "$imgType" in
    [n]|mps|dd)
        dots "Looking for Hard Disk"
        getHardDisk
        if [[ -z $hd ]]; then
            echo "Failed"
            debugPause
            handleError "Could not find hard disk"
        fi
        echo "Done"
        debugPause
        diskSize=$(trim $(lsblk --bytes -dplno SIZE -I 3,8,9,179,259 $hd))
        if [[ $diskSize -gt 2199023255552 ]]; then
            layPartSize="2tB"
        fi
        display_center "Using Disk: $hd"
        echo
        validResizeOS
        enableWriteCache $hd
        ;;
    mpa)
        dots "Looking for Hard Disks"
        getHardDisk "true"
        if [[ -z $disks ]]; then
            echo "Failed"
            debugPause
            handleError "Count not find any disks"
        fi
        echo "Done"
        debugPause
        display_center "Using Disks: $disks"
        ;;
esac
echo
echo " * Preparing Partition layout"
echo
case "$imgType" in
    # Resizable partitioning
    n)
        display_center "Wiping $hd partition information"
        initHardDisk $hd
        dots "Recreating partition layout"
        if [[ $nombr == 1 ]]; then
            echo "Skipped"
        else
            dd if=/dev/zero of=$hd bs=512 count=20 >/dev/null 2>&1
            if [[ $? != 0 ]]; then
                echo "Failed"
                debugPause
                handleError "Fatal Error: Could not clear partition table"
            fi
            parted -s $hd mktable msdos >/dev/null 2>&1
            if [[ $? != 0 ]]; then
                echo "Failed"
                debugPause
                handleError "Fatal Error: Could not initialize disk"
            fi
            dd if=$mbrfile of=$hd bs=512 count=1 >/dev/null 2>&1
            if [[ $? != 0 ]]; then
                echo "Failed"
                debugPause
                handleError "Fatal Error: Could not recreate MBR table"
            fi
        fi
        runPartprobe $hd
        echo "Done"
        debugPause
        do_fill=$(fillDiskWithPartitionsIsOK "$hd" "$imagePath" "1")
        case "$osid" in
            50)
                if [[ ! -d $imagePath ]]; then
                    handleError "Unable to locate image store"
                fi
                prepareResizeDownloadPartitions
                ;;
            [1-2])
                if [[ ! -f $imagePath && ! -f $imagePath/$img ]]; then
                    handleError "Unable to locate image store"
                fi
                if [[ -d $imagePath ]]; then
                    imagePath="$imagePath/$img"
                fi
                dots "Removing partition"
                parted -s $hd rm 1 >/dev/null 2>&1
                if [[ $? != 0 ]]; then
                    echo "Failed"
                    debugPause
                    handleError "Fatal Error: Could not remove old partition"
                fi
                echo "Done"
                debugPause
                dots "Attempting to expand/fill partitions"
                if [[ $do_fill != 0 ]]; then
                    fillDiskWithPartitions "$hd" "$imagePath" "1"
                    echo "Done"
                else
                    parted -s $hd mkpart primary ntfs 63s -- $layPartSize >/dev/null 2>&1
                    if [[ $? != 0 ]]; then
                        echo "Failed"
                        debugPause
                        handleError "Fatal Error: Could not recreate first partition"
                    fi
                    echo "Done"
                fi
                debugPause
                dots "Setting boot partition"
                parted -s $hd set 1 boot on >/dev/null 2>&1
                if [[ $? != 0 ]]; then
                    echo "Failed"
                    debugPause
                    handleError "Fatal Error: Could not make partition bootable"
                fi
                runPartprobe $hd
                echo "Done"
                debugPause
                getPartitions $hd
                for part in $parts; do
                    break
                done
                ;;
            [5-7]|9)
                if [[ ! -d $imagePath && ! -f $win7imgroot/sys.img.000 ]]; then
                    handleError "Unable to locate image store"
                elif [[ ! -f $win7imgroot/sys.img.000 ]]; then
                    prepareResizeDownloadPartitions
                else
                    echo " * Using legacy style partition setup"
                    win7partcnt=1
                    dots "Windows Boot Partition Exists"
                    if [[ ! -f $win7imgroot/gpt.bak && ! -f $win7imgroot/rec1.img.000 && ! -f $win7imgroot/rec.img.000 ]]; then
                        echo "No"
                    else
                        echo "Yes"
                        if [[ -f $win7imgroot/rec.img.000 ]]; then
                            win7partcnt=2
                        elif [[ -f $win7imgroot/gpt.bak ]]; then
                            win7partcnt=3
                        fi
                    fi
                    debugPause
                    case "$win7partcnt" in
                        1)
                            dots "Removing partition"
                            parted -s $hd rm 1 >/dev/null 2>&1
                            if [[ $? != 0 ]]; then
                                echo "Failed"
                                debugPause
                                handleError "Fatal Error: Could not remove old partition"
                            fi
                            echo "Done"
                            debugPause
                            dots "Attempting to expand/fill partitions"
                            if [[ $do_fill != 0 ]]; then
                                fillDiskWithPartitions "$hd" "$imagePath" "1"
                                echo "Done"
                            else
                                startsector="2048s"
                                if [[ $imgFormat == 1 || $imgLegacy == 1 ]]; then
                                    startsector="63s"
                                fi
                                parted -s $hd mkpart primary ntfs $startsector -- $layPartSize >/dev/null 2>&1
                                if [[ $? != 0 ]]; then
                                    echo "Failed"
                                    debugPause
                                    handleError "Fatal Error: Could not recreate first partition"
                                fi
                                echo "Done"
                            fi
                            debugPause
                            dots "Setting boot partition"
                            parted -s $hd set 1 boot on >/dev/null 2>&1
                            if [[ $? != 0 ]]; then
                                echo "Failed"
                                debugPause
                                handleError "Fatal Error: Could not make partition bootable"
                            fi
                            echo "Done"
                            ;;
                        2)
                            dots "Removing main partition"
                            parted -s $hd rm 2 >/dev/null 2>&1
                            if [[ $? != 0 ]]; then
                                echo "Failed"
                                debugPause
                                handleError "Fatal Error: Could not remove old partition"
                            fi
                            echo "Done"
                            debugPause
                            dots "Attempting to expand/fill partitions"
                            if [[ $do_fill != 0 ]]; then
                                fillDiskWithPartitions "$hd" "$imagePath" "1"
                                echo "Done"
                            else
                                startsector=$defaultpart2start
                                parted -s $hd mkpart primary ntfs $startsector -- $layPartSize >/dev/null 2>&1
                                if [[ $? != 0 ]]; then
                                    echo "Failed"
                                    debugPause
                                    handleError "Fatal Error: Could not recreate main partition"
                                fi
                                echo "Done"
                            fi
                            ;;
                        3)
                            dots "Ensuring $hd is clean"
                            sgdisk --zap-all $hd >/dev/null 2>&1
                            if [[ $? != 0 ]]; then
                                echo "Failed"
                                debugPause
                                handleError "Fatal Error: Could not clean disk"
                            fi
                            echo "Done"
                            debugPause
                            dots "Attempting to expand/fill partitions"
                            if [[ $do_fill != 0 ]]; then
                                fillDiskWithPartitions "$hd" "$imagePath" "1"
                                echo "Done"
                            else
                                sgdisk --mbrtogpt --load-backup=$win7imgroot/gpt.bak --move-second-header $hd >/dev/null 2>&1
                                if [[ $? != 0 ]]; then
                                    echo "Failed"
                                    debugPause
                                    handleError "Fatal Error: Could not place partitions"
                                fi
                                sgdisk -x 3:$(sgdisk -E $hd) $hd >/dev/null 2>&1
                                if [[ $? != 0 ]]; then
                                    echo "Failed"
                                    debugPause
                                    handleError "Fatal Error: Could not resize main partition"
                                fi
                                echo "Done"
                            fi
                            ;;
                    esac
                    runPartprobe $hd
                    debugPause
                    dots "Setting up partition variables"
                    getPartitions $hd
                    for part in $parts; do
                        case "$osid" in
                            [1-2])
                                break
                                ;;
                            [5-7]|9)
                                if [[ $win7partcnt == $(getPartitionNumber $part) ]]; then
                                    win7sys=$part
                                    break
                                fi
                                if [[ $win7partcnt == 2 && $(getPartitionNumber $part) == 1 ]]; then
                                    win7rec=$part
                                elif [[ $win7partcnt == 3 ]]; then
                                    if [[ $(getPartitionNumber $part) == 1 ]]; then
                                        win7rec1=$part
                                    elif [[ $(getPartitionNumber $part) == 2 ]]; then
                                        win7rec2=$part
                                    fi
                                fi
                                ;;
                        esac
                    done
                    echo "Done"
                    debugPause
                fi
                ;;
        esac
        ;;
    mps)
        if [[ ! -d $imagePath ]]; then
            handleError "Unable to locate image store"
        fi
        display_center "Wiping $hd partition information"
        initHardDisk $hd
        restorePartitionTablesAndBootLoaders "$hd" "1" "$imagePath"
        runPartprobe $hd
        gptcheck="$global_gptcheck"
        ;;
    mpa)
        if [[ ! -d $imagePath ]]; then
            handleError "Unable to locate image store"
        fi
        getHardDisk "true"
        intDisk=1
        for disk in $disks; do
            display_center "Wiping $disk partition information"
            initHardDisk $disk
            restorePartitionTablesAndBootLoaders "$disk" "$intDisk" "$imagePath"
            runPartprobe $disk
            gptcheck="$global_gptcheck"
            let intDisk+=1
        done
        ;;
esac
echo
display_center "+--------------------------------+"
display_center "|  Attempting to download image  |"
display_center "+--------------------------------+"
echo
display_center "+--------------------------------+"
if [[ $imgFormat == 1 || $imgLegacy == 1 ]]; then
    display_center "|         Using Partimage        |"
else
    display_center "|         Using Partclone        |"
fi
display_center "+--------------------------------+"
echo
usleep 5000000
case "$imgType" in
    n)
        case "$osid" in
            [1-2])
                if [[ ! -f $imagePath ]]; then
                    handleError "Fatal Error: Could not locate file"
                fi
                restorePartition "$part"
                ;;
            [5-7]|9)
                if [[ ! -d $imagePath && ! -f $win7imgroot/sys.img.000 ]]; then
                    handleError "Fatal Error: Could not locate file"
                elif [[ ! -f $win7imgroot/sys.img.000 ]]; then
                    # saveEBR/restoreEBR are to support the resized partitions,
                    # on MBR tables since the partition image will contain the
                    # old, and potentially incorrect, EBR Data
                    # If the partition does not make sense to save/restore the
                    # EBR, then the functions skip it.
                    for recpart in $(getValidRestorePartitions "$hd" "1" "$imagePath"); do
                        tmpebrfilename=$(tmpEBRFileName "1" "$(getPartitionNumber $recpart)")
                        saveEBR "$recpart" "$tmpebrfilename"
                        usleep 2000000
                        restorePartition "$recpart"
                        restoreEBR "$recpart" "$tmpebrfilename"
                        expandPartition "$recpart"
                    done
                    makeAllSwapSystems "$hd" "1" "$imagePath" "$imgPartitionType"
                else
                    case "$win7partcnt" in
                        1)
                            restorePartition "$win7sys"
                            ;;
                        2)
                            for winpart in "$win7rec $win7sys"; do
                                restorePartition "$winpart"
                            done
                            ;;
                        3)
                            for winpart in "$win7rec1 $win7rec2 $win7sys"; do
                                restorePartition "$winpart"
                            done
                            ;;
                    esac
                    for recpart in $(getValidRestorePartitions "$hd" "1" "$imagePath"); do
                        expandPartition "$recpart"
                    done
                fi
                ;;
            50)
                # saveEBR/restoreEBR are to support the resized partitions,
                # on MBR tables since the partition image will contain the
                # old, and potentially incorrect, EBR Data
                # If the partition does not make sense to save/restore the
                # EBR, then the functions skip it.
                for recpart in $(getValidRestorePartitions "$hd" "1" "$imagePath"); do
                    tmpebrfilename=$(tmpEBRFileName "1" "$(getPartitionNumber $recpart)")
                    saveEBR "$recpart" "$tmpebrfilename"
                    usleep 2000000
                    restorePartition "$recpart"
                    restoreEBR "$recpart" "$tmpebrfilename"
                    expandPartition "$recpart"
                done
                makeAllSwapSystems "$hd" "1" "$imagePath" "$imgPartitionType"
                ;;
        esac
        ;;
    mps)
        for recpart in $(getValidRestorePartitions "$hd" "1" "$imagePath"); do
            if [[ $imgPartitionType == all || $imgPartitionType == $(getPartitionNumber $recpart) ]]; then
                restorePartition "$recpart" "1" "$imagePath" "$imgPartitionType"
            else
                echo " * Skipping partition $recpart"
            fi
        done
        makeAllSwapSystems "$hd" "1" "$imagePath" "$imgPartitionType"
        ;;
    mpa)
        for disk in $disks; do
            for recpart in $(getValidRestorePartitions "$disk" "1" "$imagePath"); do
                if [[ $imgPartitionType == all || $imgPartitionType == $(getPartitionNumber $recpart) ]]; then
                    restorePartition "$recpart" "$intDisk" "$imagePath" "$imgPartitionType"
                else
                    echo " * Skipping partition $recpart"
                fi
            done
            makeAllSwapSystems "$disk" "1" "$imagePath" "$imgPartitionType"
            let intDisk+=1
        done
        ;;
    dd)
        restorePartition "$hd"
        ;;
esac
dots "Stopping FOG Status Reporter"
kill -9 $statusReporter >/dev/null 2>&1
if [[ $? != 0 ]]; then
    echo "Failed"
else
    echo "Done"
fi
debugPause
if [[ -f /images/postdownloadscripts/fog.postdownload ]]; then
    postdownpath="/images/postdownloadscripts/"
    . ${postdownpath}fog.postdownload
fi
if [[ $capone != 1 ]]; then
    if [[ $osid == +([1-2]|[5-7]|9) ]]; then
        getHardDisk "true"
        for disk in "$disks"; do
            getPartitions $disk
            for part in $parts; do
                if [[ $(fsTypeSetting $part) == ntfs ]]; then
                    changeHostname
                fi
            done
        done
    fi
    . /bin/fog.imgcomplete
fi
echo " * Rebooting system as task is complete"
debugPause
